---
layout: page
title: 映射到表格
parent: 配表系统
nav_order: 5
---

# 映射到表格
{: .no_toc }

{: .no_toc .text-delta }

- TOC
{:toc}
---

```
我们设计的数据支持嵌套，多态，递归嵌套，非常灵活；而excel是基于表格的结构。
如何把这种非常灵活的树状甚至递归的结构，映射到excel的一层的平坦的表格结构中呢？
```

## 结构映射到excel表格

以上我们支持嵌套结构，多态结构，递归结构，非常灵活；而excel是基于表格的结构。
如何把这种非常灵活的树状甚至递归的结构，映射到excel的一层的平坦的表格结构中呢？

这里我们有auto，pack, sep, fix, block五种映射方式。

### auto

适用type: primitive, struct, interface。

占格子数：primitive都是1，struct，interface则自动计算，不需要配置，默认就是auto

> Range中rmin占一列，rmax占一列，Range结构共占两列

### pack

适用type: struct, interface, list, map。

推荐使用，使用,;()来写任何结构

> ConditionAnd.cond1 cond2都设置了(pack)，则这两个field各占一列，ConditionAnd 总共占2列。
>
> 对于这个形成了环的递归结构，必须在某处用pack打断，要不然所占列数就无法计算。这里就是cond1，cond2处打断的。
>
> 可以看到compeletecondition下4个struct最多占2列，则compeletecondition占2+1=3列，因为名称KillMonster或TalkNpc...要占第一列。
>
> 至于pack如何以,;()写任意结构，参考 [复杂结构的单元格]



### sep

适用type: struct, list

参数sep: 可以是, : = $等等都可以，用一个字符

* struct里field只有都是primitive，才能设置sep
* 不支持type为struct的field上设置sep（请在struct上设置，为了简单一致性）
* 如果field是list,struct结构，list这配置的sep和要struct配置的sep有区分才行（不支持在此field上配置struct的sep，为了方便理解，不要这种灵活性）。

> Time 设置了(sep=':')，这样这个结构只占一列，并且具体数据可以是"12:10:00"
>
> 如果不是特别需要用某个分隔符，建议用更强大的pack

### fix

适用type: list, map

参数count：个数，占格子数 = 容器内元素占的格子 * count

* 横向扩展格子，当事先明确count限制，并且count不太大时，推荐使用

> RewardItem.itemids 设置fix=2，list里的单个item类型int占1列，所以此field占1*2=2列。
> RewardItem总共占5列。

### block

适用type: list, map

参数fix： 跟fix的count参数含义一致。

* fix参数负责横向扩展格子。
* 本身纵向随意扩展，会占用任意多行。

> task.rewardItems 配置block=1，list里的RewardItem占5列，所以此field占5*1=5列。


## block

- 读取block的算法如下：
```java
if (line.getFirst().isCellEmpty()) {  // 第一格为空，还是本record
    DCell prevCell = line.get(firstColIndex - 1);
    DCell thisCell = line.get(firstColIndex);

    if (prevCell.isCellEmpty()) { // 上一格为空，
        if (thisCell.isCellEmpty()) { // 本格也为空，内部的嵌套block，忽略
        } else { //本格不为空 -》 是这个block了
            res.add(new CellsWithRowIndex(line.subList(firstColIndex, firstColIndex + colSize), row));
        }
    } else {// 上一个不为空，结束
        break;
    }
} else { // 下一个record，结束
    break;
}
```

- block支持嵌套
```
// 要允许block<struct>,struct里仍然有block，如下所示
//1. xxxaebbxccc
//2.      bb cc
//3.      bb
//4.    aebb
//5.      bb
// 这里aeb是个block=1，b是个block=2，c是个block=3
// aebb前面一列要有空格，bb前一列格子也要是空，ccc前一列也是有个空，
// 用这个空来做为标记，支持block aebb嵌套block bb，来判断此行bb是否属于嵌套的bb还是新起的aabb
// 这样也强制了2个同级的block不要直接衔接，视觉上不好区分，
// 可以在中间加入一个列，比如以上的aebb和ccc直接有x来分割
// 以上规则现在没有做检测，要检测有点复杂，人工保证吧。
```
假如以上第4行的aebb，e这个excel格子为空，则地4.5行只提取出来了bb信息，合并到第1行整体的aeb结构里，而不是从第四行又新建了个aeb结构。
这个容易引起bug，如何避免？下节引入mustFill

## mustFill

- 可以在field上加mustFill。list、map类型表示元素个数必须大于0，其他类型表示格子不能为空。
- 为避免上一节aeb里的e格子可为空，导致的惊讶，可以设置e对应的field (mustFill)，这样万一忘了填e格子，会报错

> task.exp 设置了mustFill，表示必须配置，不能省略

## auto示例

```
table weapon[id] {
    id:int;
    weaponAttrs:weaponAttr; // Damage
}

interface weaponAttr{
    struct Damage {
        value:int;
    }
}
```

| id  | Damage      | Damage      |
| --- | ----------- | ----------- |
| id  | weaponAttrs | weaponAttrs |
| 1   | Damage      | 2           |
| 2   | Damage      | 2           |

没有pack，此时类型和数值需要拆分到2格



## Fix 设置list

```
interface weaponAttr (pack){
	struct Damage{
		value:int;
	}
}

table test[id] {
	id:str; // 注释行
	weaponAttrs:list<weaponAttr>(fix=2); // Damage
}
```

| id  |             |             |             |             |
| --- | ----------- | ----------- | ----------- | ----------- |
| id  | weaponAttrs | weaponAttrs | weaponAttrs | weaponAttrs |
| 1   | Damage      | 2           |             |             |
| 2   | Damage      | 2           |             |             |

## Pack Struct

有两种做法，一个是标注在struct上，一个是标注在变量上

```
struct DmgRatio1 {
	playerAttr:int;
	ratio:int;
}

struct DmgRatio2 (pack) {
	playerAttr:int;
	ratio:int;
}
struct DmgRatio3 {
	playerAttr:int;
	ratio:int;
}
table test[id] {
	id:int; // 注释行
	DmgRatio1:DmgRatio1; // Damage
	DmgRatio2:DmgRatio2;
	DmgRatio3:DmgRatio3(pack);
}
```

| id  |           |           |           |           |
| --- | --------- | --------- | --------- | --------- |
| id  | DmgRatio1 | DmgRatio1 | DmgRatio2 | DmgRatio3 |
| 1   | 1         | 1         | 2,2       | 3,3       |

## Interface

出现Interface时，配置里必须要表明struct的类型。

```
interface IDmgRatio{
    struct DmgRatio1 {
        playerAttr:int;
        ratio:int;
    }

    struct DmgRatio2 {
    	playerAttr:int;
    	ratio:int;
    }
}

table test[id] {
	id:int; // 注释行
	DmgRatio1:IDmgRatio;
	DmgRatio2:IDmgRatio;
}
```

| id  |           |           |           |           |           |           |
| --- | --------- | --------- | --------- | --------- | --------- | --------- |
| id  | DmgRatio1 | DmgRatio1 | DmgRatio1 | DmgRatio2 | DmgRatio2 | DmgRatio2 |
| 1   | DmgRatio1 | 1         | 1         | DmgRatio2 | 2         | 2         |

## Pack Interface

出现interface时，pack只能标注在interface上，不能标注在struct上。导致所有类型都变成1格。

```
interface IDmgRatio(pack){
    struct DmgRatio1 {
        playerAttr:int;
        ratio:int;
    }

    struct DmgRatio2 {
    	playerAttr:int;
    	ratio:int;
    }
}

table test[id] {
	id:int; // 注释行
	DmgRatio1:IDmgRatio;
	DmgRatio2:IDmgRatio;
}
```



## Pack list

先看原始的：

```
interface TestAttr (pack) {
	struct Damage {
		value:int;
	}

	struct Range {
		value:int;
	}

}

struct TestStruct (pack) {
	playerAttr:int;
	ratio:int;
}

table test[id] {
	id:int; // 注释行
	TestStruct:list<TestStruct> (pack);
	attrs:list<TestAttr>(pack);
	sepAttr:list<TestAttr>(sep=';');
}


```

| id  | TestStruct | TestStruct | attrs  | attrs | attrs | attrs |
| --- | ---------- | ---------- | ------ | ----- | ----- | ----- |
| 1   | 1,2        | 1,2        | Damage | 50    | Range | 6     |

## 对Interface和struct做pack，sep

```
interface TestAttr (pack) {
	struct Damage {
		value:int;
	}

	struct Range {
		value:int;
	}

}

struct TestStruct (pack) {
	playerAttr:int;
	ratio:int;
}

table test[id] {
	id:int; // 注释行
	TestStruct:list<TestStruct> (pack);
	attrs:list<TestAttr>(pack);
	sepAttr:list<TestAttr>(sep=';');
}


```

| id  | TestStruct  | attrs               | sepAttr             |
| --- | ----------- | ------------------- | ------------------- |
| 1   | (1,2),(2,4) | Damage(50),Range(6) | Damage(50);Range(6) |
