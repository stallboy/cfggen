---
layout: page
title: 映射到表格
parent: 配表系统
nav_order: 5
---

# 映射到表格
{: .no_toc }

{: .no_toc .text-delta }

- TOC
{:toc}
---

```
我们设计的数据支持嵌套，多态，递归嵌套，非常灵活；而excel是基于表格的结构。
如何把这种非常灵活的树状甚至递归的结构，映射到excel的一层的平坦的表格结构中呢？
```

## 结构映射到excel表格

这里我们有auto，pack, sep, fix, block五种映射方式。

### auto

- **适用类型**：primitive、struct、interface
- **占格规则**：primitive占1格，struct/interface自动计算
- **示例**：

  ```
  struct Range {
      rmin:int; // 最小
      rmax:int; // 最大
  }
  ```
  
  Range结构占2列

### pack

- **适用类型**：struct、interface、list、map
- **占格规则**：整个结构压缩到1格
- **分隔符**：使用逗号或分号分隔，内嵌结构使用()来包裹
- **示例**：

  ```
  struct Position (pack) {
      x:int;
      y:int;
      z:int;
  }
  ```

  数据格式："1,2,3"

  ```
  list<Position> (pack)
  ```

  数据格式："(1,2,3);(4,5,6)"

- 当有结构成环(递归)时，必然要有一处设置pack，打破环，这样才能计算所占列数


### sep

- **适用类型**：struct、list
- **占格规则**：整个结构压缩到1格
- **分隔符**：自定义分隔符（:、=、$等）
- **示例**：

  ```
  struct Time (sep=':'){
      hour:int;
      minute:int;
      second:int;
  }
  ```

  数据格式："12:10:00"

- struct里field只有都是primitive，才能设置sep
- 不支持type为struct的field上设置sep（请在struct上设置，为了简单一致性）
- 如果field是`list<struct>`结构，sep和要的分割符有区分才行
- 如果不是特别需要用某个分隔符，建议用更强大的pack


### fix

- **适用类型**：list、map
- **占格规则**：固定列数 = 元素类型占格 × count
- **参数**：count - 固定长度
- **示例**：

  ```
  list<int> (fix=2) // 占2列
  ```

### block

- **适用类型**：list、map
- **占格规则**：横向固定，纵向扩展
- **参数**：fix - 横向列数
- **示例**：

  ```
  list<RewardItem> (block=1) // 横向占1×RewardItem列数，纵向任意
  ```


## block算法

- 读取block的算法如下：

	```java
	if (line.getFirst().isCellEmpty()) {  // 第一格为空，还是本record
		DCell prevCell = line.get(firstColIndex - 1);
		DCell thisCell = line.get(firstColIndex);

		if (prevCell.isCellEmpty()) { // 上一格为空，
			if (thisCell.isCellEmpty()) { // 本格也为空，内部的嵌套block，忽略
			} else { //本格不为空 -》 是这个block了
				res.add(new CellsWithRowIndex(line.subList(firstColIndex, firstColIndex + colSize), row));
			}
		} else {// 上一个不为空，结束
			break;
		}
	} else { // 下一个record，结束
		break;
	}
	```

- block支持嵌套

	```java
	// 要允许block<struct>,struct里仍然有block，如下所示
	//1. xxxaebbxccc
	//2.      bb cc
	//3.      bb
	//4.    aebb
	//5.      bb
	// 这里aeb是个block=1，b是个block=2，c是个block=3
	// aebb前面一列要有空格，bb前一列格子也要是空，ccc前一列也是有个空，
	// 用这个空来做为标记，支持block aebb嵌套block bb，来判断此行bb是否属于嵌套的bb还是新起的aabb
	// 这样也强制了2个同级的block不要直接衔接，视觉上不好区分，
	// 可以在中间加入一个列，比如以上的aebb和ccc直接有x来分割
	// 以上规则现在没有做检测，要检测有点复杂，人工保证吧。
	```

	假如以上第4行的aebb，e这个excel格子为空，则地4.5行只提取出来了bb信息，合并到第1行整体的aeb结构里，而不是从第四行又新建了个aeb结构。

	这个容易引起bug，如何避免？下节引入mustFill

## mustFill

- 可以在field上加mustFill。list、map类型表示元素个数必须大于0，其他类型表示格子不能为空。
- 为避免上一节aeb里的e格子可为空，导致的惊讶，可以设置e对应的field (mustFill)，这样万一忘了填e格子，会报错

  ```
  exp:taskexp (mustFill);  // 经验奖励
  rewardItems:list<RewardItem> (block=1); // 物品奖励
  ```

  exp 设置了mustFill，表示必须配置，不能省略

## 例子

### auto

```
table weapon[id] {
    id:int;
    weaponAttrs:weaponAttr; // Damage
}

interface weaponAttr{
    struct Damage {
        value:int;
    }
}
```

| id  | weaponAttrs | weaponAttrs |
| --- | ----------- | ----------- |
| 1   | Damage      | 2           |
| 2   | Damage      | 2           |

没有pack，此时类型和数值需要拆分到2格



### Fix List

```
interface weaponAttr (pack){
	struct Damage{
		value:int;
	}
}

table test[id] {
	id:str; // 注释行
	weaponAttrs:list<weaponAttr>(fix=2); // Damage
}
```

| id  | weaponAttrs | weaponAttrs | weaponAttrs | weaponAttrs |
| --- | ----------- | ----------- | ----------- | ----------- |
| 1   | Damage      | 2           |             |             |
| 2   | Damage      | 2           |             |             |

### Pack Struct

有两种做法，一个是标注在struct上，一个是标注在变量上

```
struct DmgRatio1 {
	playerAttr:int;
	ratio:int;
}

struct DmgRatio2 (pack) {
	playerAttr:int;
	ratio:int;
}
struct DmgRatio3 {
	playerAttr:int;
	ratio:int;
}
table test[id] {
	id:int; // 注释行
	DmgRatio1:DmgRatio1; // Damage
	DmgRatio2:DmgRatio2;
	DmgRatio3:DmgRatio3(pack);
}
```

| id  | DmgRatio1 | DmgRatio1 | DmgRatio2 | DmgRatio3 |
| --- | --------- | --------- | --------- | --------- |
| 1   | 1         | 1         | 2,2       | 3,3       |

### Interface

出现Interface时，配置里必须要表明struct的类型。

```
interface IDmgRatio{
    struct DmgRatio1 {
        playerAttr:int;
        ratio:int;
    }

    struct DmgRatio2 {
    	playerAttr:int;
    	ratio:int;
    }
}

table test[id] {
	id:int; // 注释行
	DmgRatio1:IDmgRatio;
	DmgRatio2:IDmgRatio;
}
```

| id  | DmgRatio1 | DmgRatio1 | DmgRatio1 | DmgRatio2 | DmgRatio2 | DmgRatio2 |
| --- | --------- | --------- | --------- | --------- | --------- | --------- |
| 1   | DmgRatio1 | 1         | 1         | DmgRatio2 | 2         | 2         |

### Pack Interface

出现interface时，pack只能标注在interface上，不能标注在struct上。导致所有类型都变成1格。

```
interface IDmgRatio(pack){
    struct DmgRatio1 {
        playerAttr:int;
        ratio:int;
    }

    struct DmgRatio2 {
    	playerAttr:int;
    	ratio:int;
    }
}

table test[id] {
	id:int; // 注释行
	DmgRatio1:IDmgRatio;
	DmgRatio2:IDmgRatio;
}
```


### Pack list

先看原始的：

```
interface TestAttr (pack) {
	struct Damage {
		value:int;
	}

	struct Range {
		value:int;
	}

}

struct TestStruct (pack) {
	playerAttr:int;
	ratio:int;
}

table test[id] {
	id:int; // 注释行
	TestStruct:list<TestStruct> (pack);
	attrs:list<TestAttr>(pack);
	sepAttr:list<TestAttr>(sep=';');
}


```

| id  | TestStruct | TestStruct | attrs  | attrs | attrs | attrs |
| --- | ---------- | ---------- | ------ | ----- | ----- | ----- |
| 1   | 1,2        | 1,2        | Damage | 50    | Range | 6     |

### 对Interface和struct做pack，sep

```
interface TestAttr (pack) {
	struct Damage {
		value:int;
	}

	struct Range {
		value:int;
	}

}

struct TestStruct (pack) {
	playerAttr:int;
	ratio:int;
}

table test[id] {
	id:int; // 注释行
	TestStruct:list<TestStruct> (pack);
	attrs:list<TestAttr>(pack);
	sepAttr:list<TestAttr>(sep=';');
}


```

| id  | TestStruct  | attrs               | sepAttr             |
| --- | ----------- | ------------------- | ------------------- |
| 1   | (1,2),(2,4) | Damage(50),Range(6) | Damage(50);Range(6) |


### 必须用pack的情况

``` 
interface CompleteCondition {
	struct KillMonster {
		monsterid:int;
		count:int;
	}

	struct TalkNpc {
		npcid:int;
	}

	struct CollectItem {
		itemid:int;
		count:int;
	}

	struct And {
		cond1:CompleteCondition (pack);
		cond2:CompleteCondition (pack);
	}

	
}
```

任务表为：

```
table task...{
    ...
    condition: CompleteCondition;
}
```

| condition   | param1       | param2               |
|:------------|--------------|----------------------|
| KillMonster |1001          |1                     |
| And         |TalkNpc(5)    |CollectItem(2002, 3)  |


- And 里的cond1 cond2都设置了(pack)，则这两个field各占一列，And 总共占2列。
- 对于这个形成了环的递归结构，必须在某处用pack打断，要不然所占列数就无法计算。这里就是cond1，cond2处打断的。
