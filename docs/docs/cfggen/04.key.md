---
layout: page
title: 主键、枚举、外键
parent: 配表系统
nav_order: 4
---

# 主键、枚举、外键
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

- TOC
{:toc}
---


```
主键、唯一键、枚举、入口都是访问表中一行数据的方式。
外键则把数据连成网络。
```

---

## 主键

每个table必须有主键，逻辑代码通过主键拿到对应的table中具体行。

主键可以分为以下情况：

- 简单主键

    ```
    table task[taskid] {
        taskid:int;
        text:text;
    }
    ```

    绝大多数table应该都是简单主键，类型为int，long，str

- 复合结构做为主键

    ```
    struct LevelRank {
        level:int;
        rank:int;
    }

    table jewelryrandom[lvlRank] {
        lvlRank:LevelRank;
        attack:int;
    }
    ```

    lvlRank作为一个复合结构可以作为主键。

    - 但在现在的生成lua代码中，是以引用（内存地址）而非内容比较的，需要生成lua的话不要用它

- 多个field作为主键

    ```
    table jewelryrandom[level,rank] {
        level:int;
        rank:int;
        attack:int;
    }
    ```

    level,rank两列做为主键

    - 在lua中,2个都是数字的话是可以的，只要保证第一个<1亿，第二个<1万。底层以`k + j * 100000000`为key


## 唯一键

当逻辑代码希望以多个不同的方式找到到同一行时，要选择一个方式为主键，其他方式为唯一键

```
table task[taskid] {
	taskid:int; // 任务id
	text:text;
	nexttask:int;
	rewardItems:list<RewardItem> (block=1); // 物品奖励
	[nexttask];
}
```

table中如果一行以`[`开始，以`]`结束，则表示是在定义唯一键。

以上nexttask为唯一键，需要定义唯一键的情况应该很少。

## 枚举、入口

为了不在代码中留下很多配表的主键的`魔数`，我们直接在配表中引入程序用的一列，里面是程序英文名，会生成到代码里。

- 枚举

    ```
    table itemtype[id] (enum='type'){
        id:int;
        type:str;
    }
    ```

    以上`enum='type'`，完成对枚举的声明，type这一列里将都是英文名称，不能重复，不能为空，由程序填写

- 入口

    ```
    table scene[id] (entry='entry') {
        id:int;
        entry:str;
        info:text;
    }
    ```

  以上`entry='entry'`完成对入口的声明，entry这一列，大部分都是空，但有几行，应该是英文名称，由程序填写。


## 外键

- 索引到主键

    ```
    struct RewardItem {
        chance:int; // 掉落概率
        itemids:list<int> ->item.item; // 掉落物品
        range:Range; // 数量下限
    }
    ```

    以上`->item.item`完成对`list<int>`每个int的外键声明

- 索引到唯一键

    ```
    struct AA {
        taskid:int ->task[nexttask];
    }
    ```

    以上`->task[nexttask]`,表示索引到task表的nexttask唯一键

- 使用=>索引到任意字段（生成listRef）

    ```
    table drop[dropid] {
        dropid:int =>dropItem[dropid];
        name:text;
    }
    ```

    以上`=>dropItem[dropid]`，用`=>`表明不一定指向table的唯一键，而是任意字段，生成的程序代码会返回`listRefDropId`，是个列表。

- 单独一行声明

    ```
    table monster[id] {
        id:int;
        lootId:int; // loot
        lootItemId:int; // item
        ->Loot:[lootId,lootItemId] ->lootitem;
        ->AllLoot:[lootId] ->loot[id];
    }
    ```

    如上`->Loot:[lootId,lootItemId] ->lootitem`
    - `->`：表示现在是外键定义
    - `Loot`是此外键的名称
    - `[lootId,lootItemId]` 表示本地的key由是两个field组成
    - `->lootitem` 表名索引到`lootitem`表

    ```
    table drop[dropid] {
        dropid:int;
        name:text;
        ->AllDrops:[dropid] =>dropItem[id];
    }
    ```

    如上会生成 `listRefAllDrops`，跟再field上声明的唯一区别就是这个名字后缀`AllDrops`可控。

---

**外键类型总结：**

- **`->`**：指向唯一键（主键或唯一键），生成单个引用（`refXxx`）
- **`=>`**：指向任意字段，生成列表引用（`listRefXxx`）

## nullable

```
table task[taskid] (entry='entry') {
	taskid:int ->task.taskextraexp (nullable); // 任务id
	entry:str;
	text:text;
	nexttask:int ->task (nullable);
}
```

- 可以在配置了ref的field上加nullable，表示可以找不到此外键，生成代码会是nullableRefXXX
- nullable的field，如果在excel格子中，则加强了以下约束：格子中为空才可以nullable，只要格子有内容必须能找到外键。以下两种情况例外：
    1. field是此table主键或唯一键的一部分。`task.taskid`
    2. field类型是数值（int、long、float），且内容为0。`task.nexttask`
