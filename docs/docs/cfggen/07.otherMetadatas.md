---
layout: page
title: 元数据配置
parent: 配表系统
nav_order: 7
---

# 元数据配置

本章节详细介绍配表系统中的各类元数据配置选项，这些配置用于优化数据存储、编辑器显示、国际化支持等方面。

## 概述

元数据配置是配表系统的重要组成部分，通过在表定义中添加特定的元数据标记，可以控制数据的存储格式、编辑器行为、国际化工具支持等高级功能。

---

## columnMode - 列模式配置

### 功能描述
在表的元数据中配置 `columnMode`，主要用于简化模块参数表的配置过程。

### 应用场景
- 模块化参数配置
- 动态列定义
- 批量字段管理

---

## extraSplit - 文件分割配置

### 功能描述
在表的元数据中配置 `extraSplit`，用于控制生成Lua文件时是否将数据分割为多个文件。

### 参数说明
- **默认值**: 0（不分割）
- **分割规则**: 当配置为N时，数据项每N行分割为一个文件

### 示例说明
假设数据表有250行数据，配置 `extraSplit=100`，则生成的文件分布如下：
- 原文件：100行
- 文件1：100行
- 文件2：50行

### 应用价值

#### 1. 解决技术限制
- **问题背景**: Lua单个文件不能超过65526个常量
- **解决方案**: 通过文件分割避免编译错误
- **影响文件**: `assets.lua`（资源系统自动生成的文件）

#### 2. 优化热更新
- **优势**: 减少热更新时的下载文件大小
- **示例**:
  - 物品表有10000个条目
  - 热更新时通常只修改少量数据
  - 分割为5个文件后，可能只需更新其中一个文件
  - 显著降低网络传输量

---

## json - JSON存储格式

### 功能描述
在表上设置 `json` 元数据，表示该表的数据将以独立的JSON文件形式存储。

### 编辑器支持
- 支持使用 `cfgeditor` 编辑器进行可视化编辑
- 每个数据项对应一个独立的JSON文件

### 语法示例
```
table effect[id] (json) {
	id:int;
	text:str;
	logic:EffectLogic;
}
```

---

## title - 标题字段配置

### 功能描述
在表上设置 `title` 元数据，指定用于显示标题的字段名称。

### 功能效果
在 `cfgeditor` 编辑器中显示ID时，自动附带指定的标题字段内容。

### 语法示例
```
table effectclass[name] (enum='name', title='text') {
	name:str;
	text:str;
}
```

---

## description - 描述字段配置

### 功能描述
在表上设置 `description` 元数据，指定用于显示描述的字段名称。

### 参数格式
- 支持多字段组合，使用逗号分隔
- 格式：`field1,field2,field3`

### 功能效果
在 `cfgeditor` 编辑器的简略视图中展示指定的描述字段内容。

---

## refTitle - 外键标题配置

### 功能描述
在外键字段上设置 `refTitle` 元数据，指定用于显示外键引用的字段名称。

### 应用位置
- 主要在字段上设置（因为字段包含外键引用）
- 指定目标结构的字段名称

### 功能效果
在 `cfgeditor` 编辑器中展示链接时，链接线显示为指定字段对应的值。

### 默认行为
- 默认显示为 `refXxx` 格式

---

## lang - 国际化支持

### 功能描述
在表上设置 `lang` 元数据，用于国际化方案2。

### 功能效果
生成Excel文件时：
- 第一列：主键
- 第二列：额外添加指定列
- 目的：辅助翻译人员进行本地化工作

---

## CFG文件格式规范

<details markdown="block">
<summary>CFG文件语法定义（ANTLR4格式）</summary>

以下为CFG文件的语法定义，采用ANTLR4格式，熟悉BNF语法的开发者可以参考：

```
grammar Cfg ;

schema : schema_ele* EOF ;

schema_ele: struct_decl | interface_decl | table_decl ;

struct_decl : STRUCT ns_ident metadata LC COMMENT? field_decl* foreign_decl*  RC ;

STRUCT: 'struct';

interface_decl : INTERFACE ns_ident metadata LC COMMENT? struct_decl+ RC ;

INTERFACE: 'interface';

table_decl : TABLE ns_ident key metadata LC COMMENT? key_decl* field_decl* foreign_decl*  RC ;

TABLE: 'table';

field_decl : identifier COLON type_ ( ref )? metadata SEMI COMMENT? ;

foreign_decl: REF identifier COLON key ref metadata SEMI COMMENT? ;

type_ : TLIST '<' type_ele '>' |  TMAP '<' type_ele ','  type_ele '>' | type_ele;

type_ele : TBASE | ns_ident;

TLIST : 'list';
TMAP: 'map';
TBASE : 'bool' | 'int' | 'long' | 'float' | 'str' | 'res' | 'text' ;

ref:  (REF | LISTREF) ns_ident key? ;

REF: '->';
LISTREF: '=>';

key_decl : key SEMI ;

key: '[' identifier (',' identifier)* ']' ;

COMMENT: '//' ~[\r\n]* ;

metadata : ( LP ident_with_opt_single_value ( COMMA ident_with_opt_single_value )* RP )? ;

ident_with_opt_single_value : identifier (EQ single_value)? |  minus_ident;

minus_ident: MINUS identifier;

single_value : INTEGER_CONSTANT | HEX_INTEGER_CONSTANT | FLOAT_CONSTANT | STRING_CONSTANT ;

ns_ident : identifier ( DOT identifier )* ;

identifier: IDENT | keywords;

IDENT : [a-zA-Z_] [a-zA-Z0-9_]* ;

keywords: STRUCT | INTERFACE | TABLE | TLIST | TMAP | TBASE;
```

</details>
