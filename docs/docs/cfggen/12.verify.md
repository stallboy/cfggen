---
layout: page
title: 配置验证
parent: 配表系统
nav_order: 12
---

# 配置验证

配置验证是配表系统的重要功能，帮助您在开发过程中及早发现配置错误和数据不一致问题。

## 概述

cfggen 提供了完整的验证机制，包括：

- **数据一致性检查**：验证外键引用的正确性
- **未引用记录检测**：发现孤立配置数据
- **Schema 结构验证**：检查配置定义的语法和逻辑错误
- **数据值验证**：检查配置数据的完整性和正确性

**使用方式**：

- **命令行验证**：使用 `-gen verify` 命令（本文档重点）
- **编辑器验证**：在 cfgeditor 图形界面中查看检测结果（详见[编辑器快速入门 - 检测未引用的记录](../cfgeditor/01.quickstart.md#检测未引用的记录)）

---

## -gen verify 命令

### 基本用法

```bash
java -jar cfggen.jar -datadir <配置目录> -gen verify
```

**参数说明**：

- `-datadir`：指定配表根目录，目录下必须有 `config.cfg` 文件
- `-gen verify`：执行配置验证，包括引用检查和未引用记录检测

**示例**：

```bash
java -jar cfggen.jar -datadir ../example/config -gen verify
```

### 输出信息

`-gen verify` 命令会输出以下信息：

#### 1. 引用完整性检查

自动检查所有外键引用的正确性，包括：
- 外键指向的表是否存在
- 外键指向的记录是否存在
- 外键类型是否匹配

如果发现外键引用错误，会在输出中明确指出。

#### 2. 未引用记录检测结果

**正常情况**（所有记录都被引用）：

```
未引用记录检查: 所有记录都被引用，没有发现未引用的记录。
```

**发现未引用记录**：

```
========== 未被引用的记录检查结果 ==========
共发现 2 个table中有未被引用的记录
总计 15 条记录未被引用
（理想情况下为0，因为我们提供entry、enum机制可以避免在代码中出现魔数）

==========
Table: Skill (10条未引用)
  - 1001, 火球术
  - 1002, 冰霜箭
  - 1003, 雷击术
  ...
==========
Table: Item (5条未引用)
  - 5001, 铁剑
  - 5002, 木盾
  ...
========== 检查完成 ==========
```

**输出说明**：

- **共发现 X 个table**：有多少个表存在未引用记录
- **总计 X 条记录**：所有未引用记录的总数
- **每个表的详细信息**：表名和该表的未引用记录列表
  - 最多显示 50 条记录
  - 如果设置了 `title` 元数据，会显示"ID, 标题"格式
  - 否则只显示 ID

---

## 什么是"被引用"？

一条记录被认为是"被引用的"，当它满足以下任一条件：

- **Entry/Enum 表**：它是一个 `entry` 或 `enum` 类型的表（这些是系统的顶层入口，天然被视为被引用）
- **root 标记的表**：它所在的表被标记为 `(root)` 元数据（见下文说明）
- **被外键引用**：它被其他记录通过外键关联（`->` 或 `=>`）所指向

### 特殊用途的表（root 标记）

有些表虽然看似"未引用"，但它们有特殊的访问方式，不应该被视为孤立数据。对于这类表，应该在 `.cfg` schema 定义中添加 `(root)` 元数据：

**语法示例**：

```cfg
table LevelReward[level] (root) {
    level: int
    reward: -> Item
}
```

**常见的 root 表类型**：

- **等级表**：以等级当 key 的表，程序通过 `玩家等级` 动态查找对应配置，如 `LevelReward`
- **地块表**：以地块坐标当 key 的表，程序通过 `坐标位置` 动态访问配置，如 `MapTile`
- **随机表**：用来随机选择记录的表，程序从表中随机抽取记录，如 `RandomDropPool`

**为什么需要 root 标记？**

这些表的记录通常不会被其他配置通过外键直接引用，而是由程序通过特定逻辑（等级、坐标、随机等）动态访问。标记为 `(root)` 后，未引用记录检测会跳过这些表，避免产生误报。

---

## 未引用记录的处理建议

如果发现了未引用的记录，通常有以下几种情况：

### 1. 策划正在编辑中

- 这些配置是新创建的，还没有通过外键关联到系统
- 这是正常的工作流程，您可以根据项目进度决定何时建立关联

### 2. 程序代码中使用了"魔数"

- 如果程序代码直接写死了配置 ID（魔数）来引用数据，而不是通过配置系统的 entry、enum、外键机制
- **建议**：应该将硬编码的 ID 改为使用配置的外键关联，这样可以：
  - 提高代码可维护性
  - 避免因配置 ID 变更导致的错误
  - 让配置关系更加清晰可见

### 3. 需要添加 (root) 标记

- 如果表确实属于特殊用途类型（等级表、地块表、随机表等）
- 应该在 schema 定义中添加 `(root)` 标记

---

## 最佳实践

- **定期验证**：在每个迭代开发完成后，运行一次未引用记录检测
- **CI/CD 集成**：在持续集成流程中集成 `-gen verify` 命令，自动检测配置完整性
- **及时清理**：对于确认不再使用的记录，及时清理以保持配置库的整洁
- **优先使用外键关联**：而非硬编码 ID，充分发挥配置系统的优势
- **正确标记特殊表**：为特殊用途的表添加 `(root)` 标记，确保检测结果准确
- **结合编辑器使用**：在开发过程中使用 cfgeditor 图形界面查看，在 CI/CD 中使用命令行验证

---

## Schema 验证错误（CfgSchemaErrs）

Schema 验证在解析 `.cfg` 文件时进行，检查配置定义的语法和逻辑正确性。

### 严重错误（Err）

严重错误会阻止系统继续运行，必须修复后才能继续。

| 错误代码 | 错误描述 |
|---------|---------|
| `TableNameNotLowerCase` | table 名称必须全小写 |
| `NameConflict` | table、struct、interface 名字冲突 |
| `InnerNameConflict` | field 名字冲突 |
| `TypeStructNotFound` | 类型未找到 |
| `PrimitiveFieldFmtMustBeAuto` | primitive 类型字段 fmt 必须是 auto |
| `StructFieldFmtMustBeAutoOrPack` | struct 类型字段 fmt 必须是 auto 或 pack |
| `ListFieldFmtMustBePackOrSepOrFixOrBlock` | list 类型字段 fmt 必须是 pack、sep、fix、block |
| `MapFieldFmtMustBePackOrFixOrBlock` | map 类型字段 fmt 必须是 pack、fix、block |
| `EnumRefNotFound` | interface 对应的枚举表不存在 |
| `InterfaceImplEmpty` | interface 里无 struct |
| `DefaultImplNotFound` | interface 的 defaultImpl 未找到 |
| `EntryNotFound` | table 的 entry 或 enum 对应的字段类型不是 string |
| `EntryFieldTypeNotStr` | entry 字段类型不是 string |
| `KeyNotFound` | 主键、唯一键、外键的本地键不存在 |
| `KeyTypeNotSupport` | 可以作为主键或唯一键的字段，或者是基本类型 int、long、bool、str，或者是 struct |
| `PrimaryKeyNotEnumOrIntWhenEnum` | 当表是枚举类型时，主键必须是 enum 或 int 类型 |
| `RefTableNotFound` | 外键对应的 table 不存在 |
| `RefTableKeyNotUniq` | 外键到 table.key，这里 key 不是 table 的唯一键 |
| `ListRefMultiKeyNotSupport` | one to many 的外键（listRef），这个 local key 和 remote key 都只支持单字段 |
| `RefLocalKeyRemoteKeyCountNotMatch` | 外键的 local key 和 remote key 数量不匹配 |
| `RefLocalKeyRemoteKeyTypeNotMatch` | 外键的 local key 和 remote key 类型不匹配 |
| `RefContainerNullable` | list、map 的 ref 不应该是 nullable |
| `DataHeadNameNotIdentifier` | csv 或 excel 的第二行名称不是标识符，没法作为程序名 |
| `DataHeadNameDuplicated` | csv 或 excel 的英文名 header 行上名称有重复 |
| `SplitDataHeaderNotEqual` | 文件头不匹配 |
| `JsonTableNotSupportExcel` | 标记了 json 的 table 不能有对应的 excel 文件 |
| `JsonTableNotSupportMap` | 标记为 json 的 table 不能使用 map 类型 |
| `MappingToExcelLoop` | 结构有循环而且没有用 pack，导致无法映射到 excel 列 |

### 警告（Warn）

警告不会阻止系统运行，但建议修复以避免潜在问题。

| 警告代码 | 警告描述 |
|---------|---------|
| `NameMayConflictByRef` | interface 的局部名字空间里，可能跟全局的冲突；分文件存储 schema，可能顶层名字冲突 |
| `StructNotUsed` | 结构未使用 |
| `InterfaceNotUsed` | 接口未使用 |
| `LowercaseNotOnStrOrText` | lowercase 修饰符只能用于 str 或 text 类型 |
| `SuggestTypeUnknown` | 建议的类型未知 |

### 弱警告（WeakWarn）

弱警告默认不显示，使用 `-weakwarn` 参数时才会输出。

| 弱警告代码 | 弱警告描述 |
|-----------|-----------|
| `FilterRefIgnoredByRefTableNotFound` | 经 tag 过滤后外键被忽略，因表不存在 |
| `FilterRefIgnoredByRefKeyNotFound` | 经 tag 过滤后外键被忽略，因外键不存在 |

---

## 数据验证错误（CfgValueErrs）

数据验证在读取 Excel、CSV、JSON 文件时进行，检查配置数据的完整性和正确性。

### 值错误（VErr）

值错误表示数据存在问题，需要修复。

| 错误代码 | 错误描述 |
|---------|---------|
| `ParsePackErr` | 解析 pack 字符串失败 |
| `InterfaceCellEmptyButHasNoDefaultImpl` | 空单元格类型为接口，没设置 defaultImpl |
| `InterfaceCellImplNotFound` | 接口无此实现 |
| `InternalError` | 内部错误 |
| `FieldCellSpanNotEnough` | 需要的单元格个数不匹配 |
| `FieldCellNotUsed` | 字段单元格未使用 |
| `NotMatchFieldType` | 类型不匹配 |
| `MapKeyDuplicated` | map key 重复 |
| `PrimaryOrUniqueKeyDuplicated` | 键值重复 |
| `EnumEmpty` | 枚举单元格为空 |
| `EntryContainsSpace` | 入口或枚举包含空格 |
| `EntryDuplicated` | 入口或枚举重复 |
| `MustFillButCellEmpty` | 字段标记为必填但单元格为空 |
| `RefNotNullableButCellEmpty` | ref 没设置 nullable，但单元格为空 |
| `ForeignValueNotFound` | 外键没找到对应值 |
| `JsonFileReadErr` | json 文件读取失败 |
| `JsonFileWriteErr` | json 文件写入失败 |
| `JsonStrEmpty` | json 字符串为空 |
| `JsonParseException` | json 解析异常 |
| `JsonTypeNotExist` | json 类型不存在 |
| `JsonTypeNotMatch` | json 类型不匹配 |
| `JsonValueNotMatchType` | json 值与类型不匹配 |

### 值警告（VWarn）

值警告表示可能存在数据问题，但不影响系统运行。

| 警告代码 | 警告描述 |
|---------|---------|
| `JsonHasExtraFields` | JSON 包含额外字段（可能丢失数据） |

---

## 验证流程

### 1. Schema 验证阶段

在解析 `.cfg` 文件时，系统会：

1. 解析 schema 定义
2. 检查语法错误
3. 验证类型定义
4. 检查外键引用关系
5. 收集所有 Schema 错误和警告
6. 如果存在严重错误，抛出异常并停止

### 2. 数据验证阶段

在读取 Excel、CSV、JSON 文件时，系统会：

1. 读取数据文件
2. 根据 schema 解析数据
3. 验证数据类型和格式
4. 检查外键引用完整性
5. 收集所有数据值错误和警告
6. 可以选择是否允许错误继续

### 3. 未引用记录检测

在数据加载完成后：

1. 构建表之间的引用关系图
2. 从 entry/enum 表和 root 表开始遍历
3. 标记所有被引用的记录
4. 收集未被引用的记录
5. 输出检测结果

---

## 相关文档

- [命令行工具](01.usage.md) - 了解更多命令行参数和用法
- [元数据配置](07.otherMetadatas.md#root---根表标记) - 了解 `(root)` 元数据配置
- [外键关联](04.key.md) - 了解外键的定义和使用
- [编辑器快速入门](../cfgeditor/01.quickstart.md) - 在图形界面中使用验证功能
- [最佳实践](20.bestPractices.md) - 了解配置开发的最佳实践

---

## 常见问题

### Q: 如何在 CI/CD 中集成验证？

**A**: 在 CI/CD 流程中添加以下命令：

```bash
java -jar cfggen.jar -datadir config -gen verify
```

如果检测到未引用记录或错误，命令会返回非零退出码，可以在 CI 脚本中判断。详见上方的"在 CI/CD 中集成"章节。

### Q: (root) 标记会影响代码生成吗？

**A**: 不会。`(root)` 标记只影响未引用记录检测的行为，不会改变生成的代码结构。

### Q: 如何区分警告和弱警告？

**A**:
- **警告**：默认显示，提示可能的问题，建议修复
- **弱警告**：默认不显示，需要使用 `-weakwarn` 参数才会显示，通常是次要问题

### Q: 可以只检测特定表吗？

**A**: 目前 `-gen verify` 会检测所有表。如果只想检测特定表，建议使用编辑器的图形界面。

