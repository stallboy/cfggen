---
layout: page
title: 结构定义
parent: 配表系统
nav_order: 3
---

# 结构定义
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

- TOC
{:toc}
---

```
我们的目的是要表达结构化的信息。

int,float,str,bool,long,text基础类型是构建的基本块
struct来聚合成新结构，struct可以嵌套
list,map表达列表
interface来表达多态，比如任务完成条件，有多重类型
table则既表达了struct，也是具体的数据所在。
    通过主键、唯一键、enum、entry来索引到具体一行

又通过field上设置外键，来连成数据的网络。
```

---

## struct：定义结构

- struct后接结构体名称，然后在{}里每行定义field或外键
- field：字段名名字后面加:，然后是**字段类型**
- 字段类型：
  - 基本类型primitive：bool，int，float，long，str，text
  - 聚合：struct，interface
  - 容器：list，map
- 字段类型后可以接->，表明是**外键**，后接table名称，如果不是指向table的主键，则要接[]，[]内含table的唯一键
- 字段类型后可以接=>，后接table名称[]，[]内含table的field名称 这里扩展了数据库的外键含义，
  用=>表明不一定指向table的唯一键，而是任意字段，生成的程序代码会返回listRefXxx，是个列表。
- {}内行如果以->开头，表明是外键，->后接一个identifier，然后:，然后[],[]内是字段名列表，然后是->或=>,之后跟字段类型后接的一致。
- list类型配置外键时，表明list里每个item的外键
- map类型配置外键时，表明时map里每个value的外键，（不支持key的外键配置）

### 例子

```
struct Range {
	rmin:int; // 最小
	rmax:int; // 最大
}

struct RewardItem {
	chance:int; // 掉落概率
	itemids:list<int> ->item.item (fix=2); // 掉落物品
	range:Range; // 数量范围
}

struct Time (sep=':'){
    hour:int;
    minute:int;
    second:int;
}
```

**说明：**
- `Range`结构体包含两个整数字段，表示范围的最小值和最大值
- `RewardItem`结构体中，`range`字段的类型是`Range`，这是对嵌套结构的支持
- `RewardItem.itemids`字段配置了`->item.item`，表明这个`list<int>`里每个int都指向item.item表
- `Time`结构体使用了`(sep=':')`属性，表示在Excel中可以用冒号分隔的时间格式


## interface：定义接口

- interface内定义struct做为此接口的实现类
- interface后面()内可以加**enumRef**属性，指向一个表名，这个表里会有其实现类的信息，
  假如这个表策划用excel来配，则有enumRef后策划可以不用看.cfg文件。这个表必须包含其实现类的名称，也可以给id，可以包含任意额外信息。
- ()内可以加**defaultImpl**属性，指向一个此接口实现类，如果有这个属性，则excel中可以不配置这个属性，此时程序会读成这个默认实现。
- 如果defaultImpl指向的结构，只包含一个数字或bool，并且此interface是pack，则excel中可以直接写一个数字，此时程序会读成这个默认实现，里面字段为此数字。

### 例子

```
interface completecondition (enumRef='completeconditiontype') {
	struct KillMonster {
		monsterid:int ->npc.monster;
		count:int;
	}

	struct TalkNpc {
		npcid:int ->npc.npcid;
	}

	struct ConditionAnd {
		cond1:task.completecondition (pack);
		cond2:task.completecondition (pack);
	}

	struct CollectItem {
		itemid:int ->item.item;
		count:int;
	}
}

interface taskexp (enumRef='taskexptype', defaultImpl='ConstValue', pack) {
    struct ByLevel { // 玩家等级相关
		levelcoef:float;
		value:int;
	}

	struct ByServerUpDay { // 服务器启动天数相关
		updaycoef1:float;
		updaycoef2:float;
		value:int;
	}

	struct ConstValue { // 固定值
	    value:int;
	}
}
```

**说明：**
- `completecondition`接口定义了任务完成条件的多种实现，使用了`enumRef='completeconditiontype'`属性
- `KillMonster.monsterid`字段配置了`->npc.monster`，表明这个id是个外键，指向npc.monster表
- `ConditionAnd`结构中的字段类型又是`completecondition`，形成了递归结构，可以构建任意复杂的条件组合
- `taskexp`接口定义了任务经验值公式，使用了`defaultImpl='ConstValue'`属性，Excel中大多数情况下可以直接写数字
- `taskexp`接口还使用了`pack`属性，配合`defaultImpl`，可以在Excel中直接写数字表示ConstValue实现

## table：定义表结构

- 表名后[]内是此表的**主键**
- {}内每行如果以[开始，以]结束， 则表示是在定义**唯一键**
- 否则跟struct相同每行定义field或外键。
- 表名[主键]后的()内可以包含**enum**，指向field名称，表明此表是个枚举表，excel中这一列由程序员来填写，每行都要填
- 表名[主键]后的()内可以包含**entry**，指向field名称，这个会为程序生成静态成员变量，方便代码访问。 excel中这一列由程序员来填写，只有少数行需要填写。

### 例子

```
table completeconditiontype[id] (enum='name') {
	id:int; // 任务完成条件类型
	name:str; // 程序用名字
}

table taskexptype[id] (enum='name') {
	id:int; // 经验公式类型
	name:str; // 程序用名字
}

table task[taskid] (entry='entry') {
	taskid:int ->task.taskextraexp (nullable); // 任务id
	entry:str;
	text:text; // 需要国际化的文本
	nexttask:int ->task (nullable);
	completecondition:task.completecondition; // 任务完成条件
	exp:taskexp (mustFill);  // 经验奖励
	rewardItems:list<RewardItem> (block=1); // 物品奖励
	time:Time;
	[nexttask];
}
```

**说明：**
- `completeconditiontype`表使用了`(enum='name')`属性，表明这是个枚举表，Excel中name列必须包含`completecondition`接口中所有实现类的名称
- `taskexptype`表同样使用了`(enum='name')`属性，Excel中name列必须包含`taskexp`接口中所有实现类的名称
- `task`表的主键是`taskid`，使用了`(entry='entry')`属性，表明某些行需要程序代码访问，entry列由程序员填写
- `task`表中定义了`[nexttask]`唯一键，会生成对应的访问代码`GetByNextTask`
- `task`表的`completecondition`字段类型是`task.completecondition`接口，`exp`字段类型是`taskexp`接口
- `task`表的`rewardItems`字段是`list<RewardItem>`类型，使用了`(block=1)`属性

---

## 完整例子：任务表

以下是一个完整的任务表结构定义，展示了如何将struct、interface和table组合使用：

```
struct Range {
	rmin:int; // 最小
	rmax:int; // 最大
}

struct RewardItem {
	chance:int; // 掉落概率
	itemids:list<int> ->item.item (fix=2); // 掉落物品
	range:Range; // 数量范围
}

struct Time (sep=':'){
    hour:int;
    minute:int;
    second:int;
}

interface completecondition (enumRef='completeconditiontype') {
	struct KillMonster {
		monsterid:int ->npc.monster;
		count:int;
	}

	struct TalkNpc {
		npcid:int ->npc.npcid;
	}

	struct ConditionAnd {
		cond1:task.completecondition (pack);
		cond2:task.completecondition (pack);
	}

	struct CollectItem {
		itemid:int ->item.item;
		count:int;
	}
}

interface taskexp (enumRef='taskexptype', defaultImpl='ConstValue', pack) {
    struct ByLevel { // 玩家等级相关
		levelcoef:float;
		value:int;
	}

	struct ByServerUpDay { // 服务器启动天数相关
		updaycoef1:float;
		updaycoef2:float;
		value:int;
	}

	struct ConstValue { // 固定值
	    value:int;
	}
}

table completeconditiontype[id] (enum='name') {
	id:int; // 任务完成条件类型
	name:str; // 程序用名字
}

table taskexptype[id] (enum='name') {
	id:int; // 经验公式类型
	name:str; // 程序用名字
}

table task[taskid] (entry='entry') {
	taskid:int ->task.taskextraexp (nullable); // 任务id
	entry:str;
	text:text; // 需要国际化的文本
	nexttask:int ->task (nullable);
	completecondition:task.completecondition; // 任务完成条件
	exp:taskexp (mustFill);  // 经验奖励
	rewardItems:list<RewardItem> (block=1); // 物品奖励
	time:Time;
	[nexttask];
}
```

**整体说明：**
- 这个例子展示了如何通过struct、interface和table的组合来构建复杂的配表结构
- struct用于定义基本数据结构（Range、RewardItem、Time）
- interface用于定义多态行为（completecondition、taskexp）
- table用于定义实际的数据表结构（completeconditiontype、taskexptype、task）
- 通过外键（->）和接口引用，各个组件之间形成了紧密的数据关联网络

