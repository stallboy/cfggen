Gen.Tag=extract only tag=own fields
i18n.file=generated csv filename
i18n.encoding=csv file encoding
javadata.file=java data filename
java.dir=java code root dir
java.pkg=java code package
java.encoding=java code file encoding
java.sealed=generate sealed interface, need java version >=17
java.builders=generate builder for table that in this txt file
java.schemaNumPerFile=when you have too many tables, it may exceed java compiler limit, use this to split
java.configgenDir=copy configgen genjava source files to {configgenDir}/configgen/genjava/, optional
lua.dir=lua code root dir
lua.pkg=lua code module
lua.encoding=lua code file encoding
lua.emmylua=generate EmmyLua type comment or not
lua.preload=load all config data at startup or not
lua.sharedemptytable=use one shared empty table or not
lua.shared=extract shared table
lua.packbool=pack all bool in one record to int
lua.rforoldshared=for readonly check
lua.nostr=for string memory usage check
bytes.file=csharp bytes filename
bytes.cipher=xor encryption
cs.dir=csharp code root dir
cs.pkg=csharp code package
cs.encoding=csharp code file encoding
cs.prefix=class name prefix
server.port=service port for cfgeditor.exe
server.note=storage location for non-json records
server.aicfg=configure llm parameters and single table prompt template file, please refer to doc
server.watch=x>0 means auto reload config after x seconds when data file modified
server.postrun=xx.bat or xx.sh, for extra action after config reload, multi-line comments at start of .bat can have ':: -gen ' to generate with current context, .sh is '# -gen '
byai.cfg=same as aiCfg in -gen server
byai.ask=question, generate one json per line
byai.table=table name
byai.retry=retry llm times, default 1 means no retry
json.tables=table names, separated by ;
json.dst=json file output directory
ts.tables=table names, separated by ;
ts.dst=ts file output directory
ts.encoding=ts file encoding
i18nbyid.dir=directory
i18nbyid.backup=backup directory
i18nbyid.checkWrite=test if fastexcel xlsx file write is correct (by reading again and comparing)
tsschema.tables=table names to generate, separated by ;
tsschema.dst=target directory
tsschema.encoding=generated ts file encoding

# GuiLauncher 国际化资源
GuiLauncher.Title=Configuration Generator
GuiLauncher.BasicConfiguration=Basic Configuration
GuiLauncher.AdvancedDirectories=Advanced Directories
GuiLauncher.I18nConfiguration=I18n Configuration
GuiLauncher.CommandPreview=Command Preview
GuiLauncher.LogOptions=Log Options
GuiLauncher.Output=Output
GuiLauncher.DataDir=Data Dir:*
GuiLauncher.Encoding=Encoding:
GuiLauncher.HeadRow=Head Row:
GuiLauncher.UsePOI=Use POI:
GuiLauncher.Browse=Browse...
GuiLauncher.AsRoot=As Root:
GuiLauncher.ExcelDirs=Excel Dirs:
GuiLauncher.JsonDirs=Json Dirs:
GuiLauncher.None=None
GuiLauncher.I18nFile=I18n File:
GuiLauncher.LangSwitch=Lang Switch:
GuiLauncher.Dir=Dir:
GuiLauncher.DefaultLang=Default Lang:
GuiLauncher.Verbose=Verbose (-v)
GuiLauncher.Verbose2=Verbose2 (-vv)
GuiLauncher.Profile=Profile (-p)
GuiLauncher.ProfileGC=Profile+GC (-pp)
GuiLauncher.NoWarn=No Warn
GuiLauncher.WeakWarn=Weak Warn
GuiLauncher.SelectTool=Select tool...
GuiLauncher.SelectGenerator=Select generator...
GuiLauncher.Add=Add
GuiLauncher.Remove=Remove
GuiLauncher.Copy=Copy
GuiLauncher.Run=Run
GuiLauncher.ClearOutput=Clear Output
GuiLauncher.Error=Error
GuiLauncher.PleaseSetDataDirectory=Please set data directory
GuiLauncher.SelectDataDirectory=Select Data Directory

# Usage messages
Usage.NoArgs=(no args) launch GUI for interactive configuration
Usage.DataDir=configuration data root directory, must contain file: config.cfg
Usage.HeadRow=csv/Excel file data head row count, default 2
Usage.Encoding=csv encoding, default GBK, if file contains BOM, use BOM encoding
Usage.I18nFile=internationalization file, not required if not using i18n
Usage.I18nEncoding=internationalization file encoding, default GBK, if file contains BOM, use BOM encoding
Usage.I18nCrLfAsLf=replace \\r\\n with \\n in strings, default false
Usage.LangSwitchDir=internationalization with language switch support
Usage.DefaultLang=default language when using langswitchdir, default zh_cn
Usage.Verify=check config constraints
Usage.SearchTo=save search results to file, default stdout
Usage.SearchTag=search partial config, default all
Usage.Search=followed by command, find matching data
Usage.BinaryToText=followed by 1 or 2 parameters (java data file, table name - use startsWith match), print table definition and data
Usage.BinaryToTextLoop=followed by 1 parameter (java data file), print table definition and data
Usage.XmlToCfg=convert .xml to .cfg file
Usage.CompareTerm=check translated terminology table
Usage.ComparePoiAndFastExcel=compare Excel cell values read by default fastexcel library with POI, print differences
Usage.UsePoi=use POI library to read Excel files, slower but supports number formats, default false
Usage.V=verbose level 1, output statistics and warnings
Usage.VV=verbose level 2, output extra info
Usage.P=profiler, memory and time monitoring
Usage.PP=profiler, memory monitoring with GC
Usage.NOWARN=do not print warnings, default prints
Usage.WEAKWARN=print weak warnings, default disabled
Usage.ToolGenStart=following tool/gen parameters separated by commas, parameter name and value separated by = or :
Usage.DefaultFalse=default is false
Usage.AsRoot=compatible with old directory structure, has ClientTables, PublicTables, ServerTables directories with .txt suffix TSV files. Can configure as 'ClientTables:noserver,PublicTables,ServerTables:noclient', use with gen's own:-noclient to extract
Usage.ExcelDirs=Excel directories, separated by comma
Usage.JsonDirs=Json directories, separated by comma. If -asroot, -exceldirs, or -jsondirs is configured, it means to explicitly use only part of directories under -datadir, not all.

# Error messages
FixSchemaErrFirst=please fix errors in cfg file before continuing
FixValueErrFirst=please fix data errors before continuing
CellToString=sheet={0},row={1},col={2},data={3}

# Tool descriptions
tool.xmltocfg=migration (convert old .xml to .cfg)
tool.fastexcelcheck=fastexcel library and POI comparison
tool.readjavadata=javadata data reading
tool.translate=translate todo file based on similar sentences and related terms
tool.term=view terminology or check terminology usage

# Generator descriptions
gen.todotranslate=translate todo file
gen.verify=verify data
gen.search=search data
gen.i18n=generate translation file (method 1: by text)
gen.i18nbyid=generate translation file (method 2: by id)
gen.java=generate java code
gen.javadata=generate java code required data
gen.cs=generate c# code
gen.bytes=generate c#/ts/go code required data
gen.lua=generate lua code (data is also code)
gen.ts=generate typescript code
gen.go=generate go code
gen.tsschema=generate specific table schema (expressed in ts)
gen.json=output specific table data as json
gen.server=provide server for cfgeditor
gen.mcpserver=provide mcp service for AI agents like claude code
gen.byai=batch generate single table data

# CSVUtil messages
CsvUtil.RowColumnCountMismatch=CSV row {0} has {1} columns, but first row has {2} columns

# PackParser messages
PackParser.ExpectedSpaceAfterParentheses=Expected whitespace after outermost parentheses
PackParser.ExtraCharsAfterParams=Extra characters after parsed parameters
PackParser.MissingFunctionName=Missing function name
PackParser.ParameterCountMismatch=Parameter count mismatch, got {0}, expected 2

# CfgSchemaAlignToData messages
CfgSchemaAlignToData.HeaderEmptyIgnored={0} header empty, ignored!
CfgSchemaAlignToData.SetComment={0}[{1}] set comment: {2} -> {3}
CfgSchemaAlignToData.RemoveComment={0}[{1}] remove old comment: {2}
CfgSchemaAlignToData.NewField={0} new field: {1}
CfgSchemaAlignToData.DeleteField={0} delete field: {1}

# CfgData messages
CfgData.TableCount=table count: {0}

# WatchAndPostRun messages
WatchAndPostRun.WatcherAlreadyStarted=file change watcher already started
WatchAndPostRun.WatcherWaitSecondsInvalid=watcher waitSecondsAfterWatchEvt < 0, ignore start
WatchAndPostRun.WatcherStarted=file change watcher started
WatchAndPostRun.BatchFileAlreadyRegistered=batch file {0} already registered for post run
WatchAndPostRun.LastModifiedNotChanged=lastModified not change
WatchAndPostRun.ReloadContextOk=reload context ok
WatchAndPostRun.ReloadContextIgnored=reload context ignored: {0}
WatchAndPostRun.FailedToRunPostRun=failed to run post run task: {0}
WatchAndPostRun.PostRunThreadJoinInterrupted=post run thread join interrupted: {0}
WatchAndPostRun.PostRunOutput=post run output: {0}
WatchAndPostRun.PostRunOk=post run ok!
WatchAndPostRun.PostRunTimeout=post run timeout
WatchAndPostRun.PostRunErr=post run err: {0}
WatchAndPostRun.PostRunInterrupted=post run interrupted: {0}


# Formatted message keys (F. prefix) - searched first by Msg interface

# CfgSchemaErrs - WeakWarn
# FilterRefIgnoredByRefTableNotFound: name, foreignKey, notFoundRefTable
F.FilterRefIgnoredByRefTableNotFound=after tag filtering, foreign key ignored because table not found. name={0}, foreignKey={1}, notFoundRefTable={2}
# FilterRefIgnoredByRefKeyNotFound: name, foreignKey, refTable, notFoundRefKey
F.FilterRefIgnoredByRefKeyNotFound=after tag filtering, foreign key ignored because key not found. name={0}, foreignKey={1}, refTable={2}, notFoundRefKey={3}

# CfgSchemaErrs - Warn
# NameMayConflictByRef: name1, name2
F.NameMayConflictByRef=in interface local namespace, may conflict with global; storing schema in separate files, top-level names may conflict. name1={0}, name2={1}
# StructNotUsed: name
F.StructNotUsed=struct not used. name={0}
# InterfaceNotUsed: name
F.InterfaceNotUsed=interface not used. name={0}
# LowercaseNotOnStrOrText: struct, field, unMatchedType
F.LowercaseNotOnStrOrText=lowercase modifier should only be on str or text type. struct={0}, field={1}, type={2}
# SuggestTypeUnknown: table, field, unknownType
F.SuggestTypeUnknown=suggested type is unknown. table={0}, field={1}, unknownType={2}

# CfgSchemaErrs - Err
# FieldHeaderSpanNotEnough: table, field, expectedSpan, headerRemain
F.FieldHeaderSpanNotEnough=field requires more columns than header provides. table={0}, field={1}, expectedSpan={2}, headerRemain={3}
# TableNameNotLowerCase: tableName
F.TableNameNotLowerCase=table name must be all lowercase. tableName={0}
# ImplNamespaceNotEmpty: sInterface, errImplName
F.ImplNamespaceNotEmpty=struct in interface cannot be in a.b format. interface={0}, implName={1}
# NameConflict: name
F.NameConflict=table, struct, interface name conflict. name={0}
# InnerNameConflict: item, name
F.InnerNameConflict=field name conflict. item={0}, name={1}
# TypeStructNotFound: struct, field, notFoundStruct
F.TypeStructNotFound=type not found. struct={0}, field={1}, notFoundStruct={2}
# PrimitiveFieldFmtMustBeAuto: struct, field, type, errFmt
F.PrimitiveFieldFmtMustBeAuto=primitive type field format must be auto. struct={0}, field={1}, type={2}, errFmt={3}
# StructFieldFmtMustBeAutoOrPack: struct, field, type, errFmt
F.StructFieldFmtMustBeAutoOrPack=struct type field format must be auto or pack. struct={0}, field={1}, type={2}, errFmt={3}
# ListFieldFmtMustBePackOrSepOrFixOrBlock: struct, field, type, errFmt
F.ListFieldFmtMustBePackOrSepOrFixOrBlock=list type field format must be pack, sep, fix, or block. struct={0}, field={1}, type={2}, errFmt={3}
# MapFieldFmtMustBePackOrFixOrBlock: struct, field, type, errFmt
F.MapFieldFmtMustBePackOrFixOrBlock=map type field format must be pack, fix, or block. struct={0}, field={1}, type={2}, errFmt={3}
# ImplFmtNotSupport: inInterface, impl, errFmt
F.ImplFmtNotSupport=impl format not supported in interface. interface={0}, impl={1}, errFmt={2}
# SepFmtStructHasUnPrimitiveField: struct
F.SepFmtStructHasUnPrimitiveField=only struct with all primitive fields can configure sep. struct={0}
# ListStructSepEqual: structural, field
F.ListStructSepEqual=list,struct structure, if both list and struct format are sep with same separator, not supported. structural={0}, field={1}
# EnumRefNotFound: sInterface, enumRef
F.EnumRefNotFound=interface enum table not found. interface={0}, enumRef={1}
# InterfaceImplEmpty: sInterface
F.InterfaceImplEmpty=interface has no struct. interface={0}
# DefaultImplNotFound: sInterface, defaultImpl
F.DefaultImplNotFound=interface defaultImpl not found. interface={0}, defaultImpl={1}
# EntryNotFound: table, entry
F.EntryNotFound=table entry or enum field type is not string. table={0}, entry={1}
# EntryFieldTypeNotStr: table, entry, errType
F.EntryFieldTypeNotStr=entry field type is not string. table={0}, entry={1}, errType={2}
# BlockTableFirstFieldNotInPrimaryKey: table
F.BlockTableFirstFieldNotInPrimaryKey=convention: block tables must have primary key in first column. table={0}
# KeyNotFound: structural, key
F.KeyNotFound=primary key, unique key, foreign key local key not found. structural={0}, key={1}
# KeyTypeNotSupport: structural, field, errType
F.KeyTypeNotSupport=fields that can be primary or unique keys are either primitive types int, long, bool, str, or struct. structural={0}, field={1}, errType={2}
# PrimaryKeyNotEnumOrIntWhenEnum: structural, field, errType, enumField
F.PrimaryKeyNotEnumOrIntWhenEnum=primary key must be enum or int when table is enum. structural={0}, field={1}, errType={2}, enumField={3}
# RefTableNotFound: table, foreignKey, errRefTable
F.RefTableNotFound=foreign key table not found. table={0}, foreignKey={1}, errRefTable={2}
# RefTableKeyNotUniq: table, foreignKey, refTable, notUniqRefKey
F.RefTableKeyNotUniq=foreign key to table.key, key is not unique key of table. table={0}, foreignKey={1}, refTable={2}, notUniqRefKey={3}
# ListRefMultiKeyNotSupport: table, foreignKey, errMultiKey
F.ListRefMultiKeyNotSupport=one-to-many foreign key (listRef), both local key and remote key only support single field. table={0}, foreignKey={1}, errMultiKey={2}
# RefLocalKeyRemoteKeyCountNotMatch: table, foreignKey
F.RefLocalKeyRemoteKeyCountNotMatch=foreign key local key and remote key count mismatch. table={0}, foreignKey={1}
# RefLocalKeyRemoteKeyTypeNotMatch: structural, foreignKey, localType, refType
F.RefLocalKeyRemoteKeyTypeNotMatch=foreign key local key and remote key type mismatch. structural={0}, foreignKey={1}, localType={2}, refType={3}
# RefContainerNullable: structural, foreignKey
F.RefContainerNullable=list, map ref should not be nullable. structural={0}, foreignKey={1}
# DataHeadNameNotIdentifier: table, notIdentifierName
F.DataHeadNameNotIdentifier=csv or excel second row name is not identifier, cannot be used as program name. table={0}, name={1}
# DataHeadNameDuplicated: table, duplicatedName
F.DataHeadNameDuplicated=csv or excel English name header has duplicate names. table={0}, duplicatedName={1}
# SplitDataHeaderNotEqual: sheet1, header1, sheet2, header2
F.SplitDataHeaderNotEqual=file headers not match. sheet1={0}, header1={1}, sheet2={2}, header2={3}
# JsonTableNotSupportExcel: table, excelSheetList
F.JsonTableNotSupportExcel=table marked json cannot have corresponding excel file. table={0}, excelSheets={1}
# JsonTableNotSupportMap: table
F.JsonTableNotSupportMap=table marked json cannot use map type. table={0}
# MappingToExcelLoop: structNameLoop
F.MappingToExcelLoop=structure has loop and doesn't use pack, cannot map to excel columns. loop={0}

# CfgValueErrs - VErr
# ParsePackErr: source, nameable, err
F.ParsePackErr=parse pack string failed. source={0}, field={1}, err={2}
# InterfaceCellEmptyButHasNoDefaultImpl: source, interfaceName
F.InterfaceCellEmptyButHasNoDefaultImpl=empty cell type is interface, no defaultImpl set. source={0}, interface={1}
# InterfaceCellImplNotFound: source, interfaceName, notFoundImpl
F.InterfaceCellImplNotFound=interface has no such implementation. source={0}, interface={1}, impl={2}
# InternalError: internal
F.InternalError=internal error. detail={0}
# FieldCellSpanNotEnough: source, nameable, field, expected, notEnoughDataSpan
F.FieldCellSpanNotEnough=required cell count mismatch. source={0}, struct={1}, field={2}, expected={3}, actual={4}
# FieldCellNotUsed: source, nameable, unused
F.FieldCellNotUsed=field cell not used. source={0}, struct={1}, unused={2}
# NotMatchFieldType: source, nameable, field, expectedType
F.NotMatchFieldType=type mismatch. source={0}, struct={1}, field={2}, expectedType={3}
# MapKeyDuplicated: source, nameable, field
F.MapKeyDuplicated=map key duplicated. source={0}, struct={1}, field={2}
# PrimaryOrUniqueKeyDuplicated: value, table, keys
F.PrimaryOrUniqueKeyDuplicated=key value duplicated. value={0}, table={1}, keys={2}
# EnumEmpty: source, table
F.EnumEmpty=enum cell is empty. source={0}, table={1}
# EntryContainsSpace: source, table
F.EntryContainsSpace=entry or enum contains space. source={0}, table={1}
# EntryDuplicated: source, table
F.EntryDuplicated=entry or enum duplicated. source={0}, table={1}
# MustFillButCellEmpty: value
F.MustFillButCellEmpty=field is marked as must fill but cell is empty. value={0}
# RefNotNullableButCellEmpty: value, recordId
F.RefNotNullableButCellEmpty=ref not set nullable, but cell is empty. value={0}, recordId={1}
# ForeignValueNotFound: value, recordId, foreignTable, foreignKey
F.ForeignValueNotFound=foreign key value not found. value={0}, recordId={1}, foreignTable={2}, foreignKey={3}
# JsonFileReadErr: jsonFile, errMsg
F.JsonFileReadErr=json file read failed. file={0}, err={1}
# JsonStrEmpty: source
F.JsonStrEmpty=json string is empty. source={0}
# JsonParseException: source, err
F.JsonParseException=json parse exception. source={0}, err={1}
# JsonTypeNotExist: source, expected
F.JsonTypeNotExist=json type does not exist. source={0}, expected={1}
# JsonTypeNotMatch: source, type, expected
F.JsonTypeNotMatch=json type does not match. source={0}, type={1}, expected={2}
# JsonValueNotMatchType: source, value, expectedType
F.JsonValueNotMatchType=json value does not match type. source={0}, value={1}, expectedType={2}

# UnreferencedRecordCollector messages
UnreferencedRecordCollector.ResultHeader========== Unreferenced Records Check Results ==========
UnreferencedRecordCollector.FoundTables=Found {0} table(s) with unreferenced records
UnreferencedRecordCollector.TotalRecords=Total {0} record(s) unreferenced
UnreferencedRecordCollector.TableInfo=Table: {0} ({1} unreferenced)
UnreferencedRecordCollector.IdeallyZero=(Ideally 0, as entry/enum mechanisms can avoid magic numbers in code)
UnreferencedRecordCollector.CheckComplete========== Check Complete ==========
UnreferencedRecordCollector.AllReferenced=Unreferenced records check: All records are referenced, no unreferenced records found.
GenVerifier.Title=Reference check; unreferenced records check (entry/enum/root counts as referenced); entry records check

# EntryRecordCollector messages
EntryRecordCollector.ResultHeader========== Entry Records Check Results ==========
EntryRecordCollector.FoundTables=Found {0} table(s) with entry records
EntryRecordCollector.TotalRecords=Total {0} record(s) as entry points
EntryRecordCollector.TableInfo=Table: {0} {1} ({2} entry records)
EntryRecordCollector.CheckComplete========== Check Complete ==========
EntryRecordCollector.NoEntry=Entry records check: No entry records found.