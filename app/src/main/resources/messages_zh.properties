NameMayConflictByRef=interface的局部名字空间里，可能跟全局的冲突;分文件存储schema，可能顶层名字冲突
StructNotUsed=结构未使用
InterfaceNotUsed=接口未使用
FilterRefIgnoredByRefTableNotFound=经tag过滤后外键被忽略，因表不存在
FilterRefIgnoredByRefKeyNotFound=经tag过滤后外键被忽略，因外键不存在
TableNameNotLowerCase=table名称必须全小写(因为windows文件名不分大小写，而table名可能就是文件名，这里直接约定必须都小写)
ImplNamespaceNotEmpty=在interface里的struct不能是a.b这种格式
NameConflict=table，struct，interface名字冲突
InnerNameConflict=field 名字冲突
TypeStructNotFound=类型未找到
PrimitiveFieldFmtMustBeAuto=primitive类型字段fmt必须是auto
StructFieldFmtMustBeAutoOrPack=struct类型字段fmt必须是auto或pack
ListFieldFmtMustBePackOrSepOrFixOrBlock=list类型字段fmt必须是pack，sep，fix，block
MapFieldFmtMustBePackOrFixOrBlock=map类型字段fmt必须是pack，fix，block
ImplFmtNotSupport=在interface的impl上不支持配置fmt
SepFmtStructHasUnPrimitiveField=只有field都是primitive类型的struct可以配置了sep
ListStructSepEqual=list,struct结构，如果list和struct的fmt都是sep，且分隔符选择相同，这也是不支持的
EnumRefNotFound=interface对应的枚举表不存在
InterfaceImplEmpty=interface里无struct
DefaultImplNotFound=interface的defaultImpl未找到
EntryNotFound=table的entry或enum对应的字段类型不是string
BlockTableFirstFieldNotInPrimaryKey=约定有block的，primary key所在列必须包含第一列(用table逻辑第一列格子是否为空来判断这行是属于上一个record的block)
KeyNotFound=主键、唯一键、外键的本地健 不存在
KeyTypeNotSupport=可以做为主键或唯一键的字段，或者是基本类型int, long, bool, str,或者是struct，struct里的字段类型必须为int，long，bool，str,或者是多个字段，构建成隐含的struct，同样要符合struct内字段类型必须为int, long, bool, str
RefTableNotFound=外键对应的table不存在
RefTableKeyNotUniq=外键到table.key，这里key不是table的唯一键
ListRefMultiKeyNotSupport=one to many的外键（listRef），这个local key和remote key都只支持单字段
RefLocalKeyRemoteKeyCountNotMatch=外键的local key和remote key数量不匹配
RefLocalKeyRemoteKeyTypeNotMatch=外键的local key和remote key类型不匹配
RefContainerNullable=list，map的ref不应该是nullable
DataHeadNameNotIdentifier=csv或excel的第二行名称不是标识符，没法作为程序名
DataHeadNameDuplicated=csv或excel的英文名header行上名称有重复
JsonTableNotSupportExcel=标记了json的table不能有对应的excel文件
MappingToExcelLoop=结构有循环而且没有用pack，导致无法映射到excel列
ParsePackErr=解析pack字符串失败
InterfaceCellEmptyButHasNoDefaultImpl=空单元格类型为接口，没设置defaultImpl
InterfaceCellImplNotFound=接口无此实现
InternalError=内部错误
FieldCellSpanNotEnough=需要的单元格个数不匹配
NotMatchFieldType=类型不匹配,
MapKeyDuplicated=map key重复
PrimaryOrUniqueKeyDuplicated=键值重复
EnumEmpty=枚举单元格为空
EntryContainsSpace=入口或枚举包含空格
EntryDuplicated=入口或枚举重复
RefNotNullableButCellEmpty=ref没设置nullable，但单元格为空
ForeignValueNotFound=外键没找到对应值
JsonFileReadErr=json文件读取失败
JsonFileParseErr=json文件解析失败
JsonFileWriteErr=json文件写入失败
FixSchemaErrFirst=请修复cfg文件里的错误后再继续
FixValueErrFirst=请修复数据错误后再继续
SplitDataHeaderNotEqual={0} 文件头: {1}和\n{2} 文件头: {3} 不匹配！
CellToString=表={0},行={1},列={2},数据={3}
Usage.DataDir=配表根目录，目录下有文件config.cfg
Usage.HeadRow=csv/Excel文件里数据头行数, 默认为2
Usage.Encoding=csv编码，默认是GBK，如果文件中含有bom则用bom标记的编码
Usage.I18nFile=国际化需要的文件，如果不用国际化，就不要配置
Usage.I18nEncoding=国际化需要的文件的编码，默认是GBK，如果文件中含有bom则用bom标记的编码
Usage.I18nCrLfAsLf=把字符串里的\\r\\n 替换为 \\n，默认是false
Usage.LangSwitchDir=国际化并且可随时切换语言
Usage.DefaultLang=langswitchdir设置时有效，表示默认的语言，默认为zh_cn
Usage.Verify=检查配表约束
Usage.SearchTo=保存搜索结果到文件, 默认是stdout
Usage.SearchTag=搜索部分配置.默认是全部
Usage.Search=后接命令，找到匹配的数据
Usage.BinaryToText=后可接1或2个参数（java data的file，table名称-用startsWith匹配），打印table的定义和数据
Usage.BinaryToTextLoop=后可接1个参数（java data的file），打印table的定义和数据
Usage.XmlToCfg=.xml变成.cfg文件
Usage.CompareTerm=检查翻译名词表
Usage.ComparePoiAndFastExcel=对默认的fastexcel库读出的excel文件单元格和poi读出来的结果做比较，打印出不同处。
Usage.UsePoi=用poi库去读excel文件，会比较慢，支持数字格式，默认false
Usage.V=verbose，级别1，输出统计和warning信息
Usage.VV=verbose，级别2，输出额外信息
Usage.P=profiler，内存和时间监测
Usage.PP=profiler，内存监测前加gc
Usage.NOWARN=不打印警告信息，默认打印
Usage.WEAKWARN=打印弱警告，默认不打印
Usage.GenStart=以下gen参数之间由,分割,参数名和参数取值之间由=或:分割
Gen.DefaultFalse=默认为false
Gen.Tag=只提取含tag的数据
Usage.AsRoot=兼容之前的目录结构，有ClientTables、PublicTables、ServerTables目录，目录下是.txt后缀的tsv文件。这里可以配置为'ClientTables:noserver,PublicTables,ServerTables:noclient',配合gen的own:-noclient来提取
Usage.ExcelDirs=excel目录，以,分隔
Usage.JsonDirs=json目录，以,分隔，-asroot、-exceldirs、-jsondirs一旦有一个配置，说明要明确只用-datadir下的部分目录，而不是全部。

i18n.file=生成文件
i18n.encoding=生成文件的编码
javadata.file=文件名
java.dir=目录
java.pkg=包名
java.encoding=生成代码文件的编码
java.sealed=生成sealed interface，需要java17
java.builders=指向txt文件，每行是一个table，对这些table生成对应的builder
java.schemanumperfile=当配表数量过多时生成的ConfigCodeSchema会超过java编译器限制，用此参数来分文
lua.dir=生成代码所在目录
lua.pkg=模块名称
lua.encoding=编码
lua.emmylua=是否生成EmmyLua相关的注解
lua.preload=是否一开始就全部加载配置，默认用到的时候再加载
lua.sharedemptytable=是否提取空table {}
lua.shared=是否提取非空的公共table
lua.packbool=是否要把同一个结构里的多个bool压缩成一个int
lua.rforoldshared=以前R用于修饰shared table，现在默认行为改为R修饰list，map
lua.nostr=只用来测试字符串占用内存大小
bytes.file=文件名
bytes.cipher=xor加密
cs.dir=目录
cs.pkg=包名
cs.encoding=生成文件的编码
cs.prefix=生成类的前缀
server.port=为cfgeditor.exe提供服务的端口
server.note=非json记录的标注存储位置
server.aicfg=配置llm参数和单个table的提示词模板文件等信息，请参考doc
server.watch=x>0表示数据文件修改x秒后自动重载配置
server.postrun=xx.bat或xx.sh，用于重载配置后的额外动作， .bat最开始多行的注释可有':: -gen '用当前上下文生成，.sh则是'# -gen '
jsonbyai.cfg=同-gen server里的aiCfg
jsonbyai.ask=问题，每行生成一个json
jsonbyai.table=表名称
jsonbyai.promptfn=默认为在<cfg>文件目录下的<table>.jte，格式参考https://jte.gg/
jsonbyai.raw=false表示是把结构信息转为typescript类型信息提供给llm
jsonbyai.retry=重试llm次数，默认1代表不重试
json.tables=表名，;分割
json.dst=json文件输出目录
ts.tables=表名，;分割
ts.dst=ts文件输出目录
ts.encoding=ts文件编码
i18nbyid.dir=目录
i18nbyid.backup=备份目录
i18nbyid.checkWrite=测试fastexcel的xlsx文件写入是否正确（用再读取一次，然后比较的方式）
tsschema.tables=要生成的表名称列表，以;分隔
tsschema.dst=目标目录
tsschema.encoding=生成的ts文件编码