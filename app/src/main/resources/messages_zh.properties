Usage.NoArgs=    (无参数)         启动图形界面进行交互式配置
FixSchemaErrFirst=请修复cfg文件里的错误后再继续
FixValueErrFirst=请修复数据错误后再继续
CellToString=表={0},行={1},列={2},数据={3}
Usage.DataDir=配表根目录，目录下有文件config.cfg
Usage.HeadRow=csv/Excel文件里数据头行数, 默认为2
Usage.Encoding=csv编码，默认是GBK，如果文件中含有bom则用bom标记的编码
Usage.I18nFile=国际化需要的文件，如果不用国际化，就不要配置
Usage.I18nEncoding=国际化需要的文件的编码，默认是GBK，如果文件中含有bom则用bom标记的编码
Usage.I18nCrLfAsLf=把字符串里的\\r\\n 替换为 \\n，默认是false
Usage.LangSwitchDir=国际化并且可随时切换语言
Usage.DefaultLang=langswitchdir设置时有效，表示默认的语言，默认为zh_cn
Usage.Verify=检查配表约束
Usage.SearchTo=保存搜索结果到文件, 默认是stdout
Usage.SearchTag=搜索部分配置.默认是全部
Usage.Search=后接命令，找到匹配的数据
Usage.BinaryToText=后可接1或2个参数（java data的file，table名称-用startsWith匹配），打印table的定义和数据
Usage.BinaryToTextLoop=后可接1个参数（java data的file），打印table的定义和数据
Usage.XmlToCfg=.xml变成.cfg文件
Usage.CompareTerm=检查翻译名词表
Usage.ComparePoiAndFastExcel=对默认的fastexcel库读出的excel文件单元格和poi读出来的结果做比较，打印出不同处。
Usage.UsePoi=用poi库去读excel文件，会比较慢，支持数字格式，默认false
Usage.V=verbose，级别1，输出统计和warning信息
Usage.VV=verbose，级别2，输出额外信息
Usage.P=profiler，内存和时间监测
Usage.PP=profiler，内存监测前加gc
Usage.NOWARN=不打印警告信息，默认打印
Usage.WEAKWARN=打印弱警告，默认不打印
Usage.ToolGenStart=以下tool/gen参数之间由,分割,参数名和参数取值之间由=或:分割
DefaultFalse=默认为false
Gen.Tag=只提取含tag的数据
Usage.AsRoot=兼容之前的目录结构，有ClientTables、PublicTables、ServerTables目录，目录下是.txt后缀的tsv文件。这里可以配置为'ClientTables:noserver,PublicTables,ServerTables:noclient',配合gen的own:-noclient来提取
Usage.ExcelDirs=excel目录，以,分隔
Usage.JsonDirs=json目录，以,分隔，-asroot、-exceldirs、-jsondirs一旦有一个配置，说明要明确只用-datadir下的部分目录，而不是全部。
i18n.file=生成文件
i18n.encoding=生成文件的编码
javadata.file=文件名
java.dir=目录
java.pkg=包名
java.encoding=生成代码文件的编码
java.sealed=生成sealed interface，需要java17
java.builders=指向txt文件，每行是一个table，对这些table生成对应的builder
java.schemaNumPerFile=当配表数量过多时生成的ConfigCodeSchema会超过java编译器限制，用此参数来分文
java.configgenDir=复制configgen genjava源文件到{configgenDir}/configgen/genjava/，可选
lua.dir=生成代码所在目录
lua.pkg=模块名称
lua.encoding=编码
lua.emmylua=是否生成EmmyLua相关的注解
lua.preload=是否一开始就全部加载配置，默认用到的时候再加载
lua.sharedemptytable=是否提取空table {}
lua.shared=是否提取非空的公共table
lua.packbool=是否要把同一个结构里的多个bool压缩成一个int
lua.rforoldshared=以前R用于修饰shared table，现在默认行为改为R修饰list，map
lua.nostr=只用来测试字符串占用内存大小
bytes.file=文件名
bytes.cipher=xor加密
cs.dir=目录
cs.pkg=包名
cs.encoding=生成文件的编码
cs.prefix=生成类的前缀
server.port=为cfgeditor.exe提供服务的端口
server.note=非json记录的标注存储位置
server.aicfg=配置llm参数和单个table的提示词模板文件等信息，请参考doc
server.watch=x>0表示数据文件修改x秒后自动重载配置
server.postrun=xx.bat或xx.sh，用于重载配置后的额外动作， .bat最开始多行的注释可有':: -gen '用当前上下文生成，.sh则是'# -gen '
byai.cfg=同-gen server里的aiCfg
byai.ask=问题，每行生成一个json
byai.table=表名称
byai.retry=重试llm次数，默认1代表不重试
json.tables=表名，;分割
json.dst=json文件输出目录
ts.tables=表名，;分割
ts.dst=ts文件输出目录
ts.encoding=ts文件编码
i18nbyid.dir=目录
i18nbyid.backup=备份目录
i18nbyid.checkWrite=测试fastexcel的xlsx文件写入是否正确（用再读取一次，然后比较的方式）
tsschema.tables=要生成的表名称列表，以;分隔
tsschema.dst=目标目录
tsschema.encoding=生成的ts文件编码
tool.xmltocfg=迁移（把之前的.xml改为.cfg）
tool.fastexcelcheck=fastexcel库和poi库比较
tool.readjavadata=javadata数据读取
tool.translate=根据相似语句和相关术语翻译todo文件
tool.term=查看术语，或检查术语使用情况
gen.todotranslate=翻译todo文件
gen.verify=检验数据
gen.search=搜索数据
gen.i18n=生成翻译文件（方案1：by 文本）
gen.i18nbyid=生成翻译文件（方案2：by id）
gen.java=生成java代码
gen.javadata=生成java代码需要的数据
gen.cs=生成c#代码
gen.bytes=生成c#/ts/go代码需要的数据
gen.lua=生成lua代码（数据也是代码）
gen.ts=生成typescript代码
gen.go=生成go代码
gen.tsschema=生成特定table的schema（用ts来表达）
gen.json=把特定table里数据输出为json
gen.server=为cfgeditor编辑器提供server
gen.mcpserver=为ai agent比如claude code提供mcp服务
gen.byai=批量生成单个table的数据

# GuiLauncher 国际化资源
GuiLauncher.Title=配置生成器
GuiLauncher.BasicConfiguration=基础配置
GuiLauncher.AdvancedDirectories=高级目录配置
GuiLauncher.I18nConfiguration=国际化配置
GuiLauncher.CommandPreview=命令预览
GuiLauncher.LogOptions=日志选项
GuiLauncher.Output=输出
GuiLauncher.DataDir=数据目录:*
GuiLauncher.Encoding=编码:
GuiLauncher.HeadRow=表头行:
GuiLauncher.UsePOI=使用 POI:
GuiLauncher.Browse=浏览...
GuiLauncher.AsRoot=As Root:
GuiLauncher.ExcelDirs=Excel Dirs:
GuiLauncher.JsonDirs=Json Dirs:
GuiLauncher.None=无需
GuiLauncher.I18nFile=I18n 文件:
GuiLauncher.LangSwitch=语言切换:
GuiLauncher.Dir=目录:
GuiLauncher.DefaultLang=默认语言:
GuiLauncher.Verbose=详细 (-v)
GuiLauncher.Verbose2=详细2 (-vv)
GuiLauncher.Profile=性能分析 (-p)
GuiLauncher.ProfileGC=性能分析+GC (-pp)
GuiLauncher.NoWarn=无警告
GuiLauncher.WeakWarn=弱警告
GuiLauncher.SelectTool=选择工具...
GuiLauncher.SelectGenerator=选择生成器...
GuiLauncher.Add=添加
GuiLauncher.Remove=删除
GuiLauncher.Copy=复制
GuiLauncher.Run=运行
GuiLauncher.ClearOutput=清空输出
GuiLauncher.Error=错误
GuiLauncher.PleaseSetDataDirectory=请设置数据目录
GuiLauncher.SelectDataDirectory=选择数据目录

# CSVUtil messages
CsvUtil.RowColumnCountMismatch=CSV第{0}行有{1}列，但第1行有{2}列，列数不匹配

# PackParser messages
PackParser.ExpectedSpaceAfterParentheses=最外层的括号后应该是空格
PackParser.ExtraCharsAfterParams=解析出参数后不能有额外字符
PackParser.MissingFunctionName=缺少函数名
PackParser.ParameterCountMismatch=参数个数不匹配，得到{0}个，期望2个

# CfgSchemaAlignToData messages
CfgSchemaAlignToData.HeaderEmptyIgnored={0}表头为空，已忽略！
CfgSchemaAlignToData.SetComment={0}[{1}]设置注释：{2} -> {3}
CfgSchemaAlignToData.RemoveComment={0}[{1}]删除旧注释：{2}
CfgSchemaAlignToData.NewField={0}新增字段：{1}
CfgSchemaAlignToData.DeleteField={0}删除字段：{1}

# CfgData messages
CfgData.TableCount=表数量：{0}

# WatchAndPostRun messages
WatchAndPostRun.WatcherAlreadyStarted=文件变化监听器已启动
WatchAndPostRun.WatcherWaitSecondsInvalid=监听器 waitSecondsAfterWatchEvt < 0，忽略启动
WatchAndPostRun.WatcherStarted=文件变化监听器已启动
WatchAndPostRun.BatchFileAlreadyRegistered=批处理文件 {0} 已注册用于后运行
WatchAndPostRun.LastModifiedNotChanged=最后修改时间未变化
WatchAndPostRun.ReloadContextOk=重新加载上下文成功
WatchAndPostRun.ReloadContextIgnored=重新加载上下文已忽略：{0}
WatchAndPostRun.FailedToRunPostRun=运行后运行任务失败：{0}
WatchAndPostRun.PostRunThreadJoinInterrupted=后运行线程加入被中断：{0}
WatchAndPostRun.PostRunOutput=后运行输出：{0}
WatchAndPostRun.PostRunOk=后运行成功！
WatchAndPostRun.PostRunTimeout=后运行超时
WatchAndPostRun.PostRunErr=后运行错误：{0}
WatchAndPostRun.PostRunInterrupted=后运行被中断：{0}

# 格式化消息key（F. 前缀）- Msg接口优先查找这些key

# CfgSchemaErrs - WeakWarn
# FilterRefIgnoredByRefTableNotFound: name, foreignKey, notFoundRefTable
F.FilterRefIgnoredByRefTableNotFound=经tag过滤后外键被忽略，因表不存在。name={0}, foreignKey={1}, notFoundRefTable={2}
# FilterRefIgnoredByRefKeyNotFound: name, foreignKey, refTable, notFoundRefKey
F.FilterRefIgnoredByRefKeyNotFound=经tag过滤后外键被忽略，因外键不存在。name={0}, foreignKey={1}, refTable={2}, notFoundRefKey={3}

# CfgSchemaErrs - Warn
# NameMayConflictByRef: name1, name2
F.NameMayConflictByRef=interface的局部名字空间里，可能跟全局的冲突；分文件存储schema，可能顶层名字冲突。name1={0}, name2={1}
# StructNotUsed: name
F.StructNotUsed=结构未使用。name={0}
# InterfaceNotUsed: name
F.InterfaceNotUsed=接口未使用。name={0}
# LowercaseNotOnStrOrText: struct, field, unMatchedType
F.LowercaseNotOnStrOrText=lowercase修饰符只能用于str或text类型。struct={0}, field={1}, type={2}
# SuggestTypeUnknown: table, field, unknownType
F.SuggestTypeUnknown=建议的类型未知。table={0}, field={1}, unknownType={2}

# CfgSchemaErrs - Err
# FieldHeaderSpanNotEnough: table, field, expectedSpan, headerRemain
F.FieldHeaderSpanNotEnough=字段需要的列数超过了header的剩余列数。table={0}, field={1}, expectedSpan={2}, headerRemain={3}
# TableNameNotLowerCase: tableName
F.TableNameNotLowerCase=table名称必须全小写。tableName={0}
# ImplNamespaceNotEmpty: sInterface, errImplName
F.ImplNamespaceNotEmpty=在interface里的struct不能是a.b这种格式。interface={0}, implName={1}
# NameConflict: name
F.NameConflict=table、struct、interface名字冲突。name={0}
# InnerNameConflict: item, name
F.InnerNameConflict=field名字冲突。item={0}, name={1}
# TypeStructNotFound: struct, field, notFoundStruct
F.TypeStructNotFound=类型未找到。struct={0}, field={1}, notFoundStruct={2}
# PrimitiveFieldFmtMustBeAuto: struct, field, type, errFmt
F.PrimitiveFieldFmtMustBeAuto=primitive类型字段fmt必须是auto。struct={0}, field={1}, type={2}, errFmt={3}
# StructFieldFmtMustBeAutoOrPack: struct, field, type, errFmt
F.StructFieldFmtMustBeAutoOrPack=struct类型字段fmt必须是auto或pack。struct={0}, field={1}, type={2}, errFmt={3}
# ListFieldFmtMustBePackOrSepOrFixOrBlock: struct, field, type, errFmt
F.ListFieldFmtMustBePackOrSepOrFixOrBlock=list类型字段fmt必须是pack、sep、fix、block。struct={0}, field={1}, type={2}, errFmt={3}
# MapFieldFmtMustBePackOrFixOrBlock: struct, field, type, errFmt
F.MapFieldFmtMustBePackOrFixOrBlock=map类型字段fmt必须是pack、fix、block。struct={0}, field={1}, type={2}, errFmt={3}
# ImplFmtNotSupport: inInterface, impl, errFmt
F.ImplFmtNotSupport=在interface的impl上不支持配置fmt。interface={0}, impl={1}, errFmt={2}
# SepFmtStructHasUnPrimitiveField: struct
F.SepFmtStructHasUnPrimitiveField=只有field都是primitive类型的struct可以配置了sep。struct={0}
# ListStructSepEqual: structural, field
F.ListStructSepEqual=list、struct结构，如果list和struct的fmt都是sep，且分隔符选择相同，这也是不支持的。structural={0}, field={1}
# EnumRefNotFound: sInterface, enumRef
F.EnumRefNotFound=interface对应的枚举表不存在。interface={0}, enumRef={1}
# InterfaceImplEmpty: sInterface
F.InterfaceImplEmpty=interface里无struct。interface={0}
# DefaultImplNotFound: sInterface, defaultImpl
F.DefaultImplNotFound=interface的defaultImpl未找到。interface={0}, defaultImpl={1}
# EntryNotFound: table, entry
F.EntryNotFound=table的entry或enum对应的字段类型不是string。table={0}, entry={1}
# EntryFieldTypeNotStr: table, entry, errType
F.EntryFieldTypeNotStr=entry字段类型不是string。table={0}, entry={1}, errType={2}
# BlockTableFirstFieldNotInPrimaryKey: table
F.BlockTableFirstFieldNotInPrimaryKey=约定有block的，primary key所在列必须包含第一列。table={0}
# KeyNotFound: structural, key
F.KeyNotFound=主键、唯一键、外键的本地键不存在。structural={0}, key={1}
# KeyTypeNotSupport: structural, field, errType
F.KeyTypeNotSupport=可以做为主键或唯一键的字段，或者是基本类型int、long、bool、str，或者是struct。structural={0}, field={1}, errType={2}
# PrimaryKeyNotEnumOrIntWhenEnum: structural, field, errType, enumField
F.PrimaryKeyNotEnumOrIntWhenEnum=当表是枚举类型时，主键必须是enum或int类型。structural={0}, field={1}, errType={2}, enumField={3}
# RefTableNotFound: table, foreignKey, errRefTable
F.RefTableNotFound=外键对应的table不存在。table={0}, foreignKey={1}, errRefTable={2}
# RefTableKeyNotUniq: table, foreignKey, refTable, notUniqRefKey
F.RefTableKeyNotUniq=外键到table.key，这里key不是table的唯一键。table={0}, foreignKey={1}, refTable={2}, notUniqRefKey={3}
# ListRefMultiKeyNotSupport: table, foreignKey, errMultiKey
F.ListRefMultiKeyNotSupport=one to many的外键（listRef），这个local key和remote key都只支持单字段。table={0}, foreignKey={1}, errMultiKey={2}
# RefLocalKeyRemoteKeyCountNotMatch: table, foreignKey
F.RefLocalKeyRemoteKeyCountNotMatch=外键的local key和remote key数量不匹配。table={0}, foreignKey={1}
# RefLocalKeyRemoteKeyTypeNotMatch: structural, foreignKey, localType, refType
F.RefLocalKeyRemoteKeyTypeNotMatch=外键的local key和remote key类型不匹配。structural={0}, foreignKey={1}, localType={2}, refType={3}
# RefContainerNullable: structural, foreignKey
F.RefContainerNullable=list、map的ref不应该是nullable。structural={0}, foreignKey={1}
# DataHeadNameNotIdentifier: table, notIdentifierName
F.DataHeadNameNotIdentifier=csv或excel的第二行名称不是标识符，没法作为程序名。table={0}, name={1}
# DataHeadNameDuplicated: table, duplicatedName
F.DataHeadNameDuplicated=csv或excel的英文名header行上名称有重复。table={0}, duplicatedName={1}
# SplitDataHeaderNotEqual: sheet1, header1, sheet2, header2
F.SplitDataHeaderNotEqual=文件头不匹配。sheet1={0}, header1={1}, sheet2={2}, header2={3}
# JsonTableNotSupportExcel: table, excelSheetList
F.JsonTableNotSupportExcel=标记了json的table不能有对应的excel文件。table={0}, excelSheets={1}
# JsonTableNotSupportMap: table
F.JsonTableNotSupportMap=标记为json的table不能使用map类型。table={0}
# MappingToExcelLoop: structNameLoop
F.MappingToExcelLoop=结构有循环而且没有用pack，导致无法映射到excel列。loop={0}

# CfgValueErrs - VErr
# ParsePackErr: source, nameable, err
F.ParsePackErr=解析pack字符串失败。source={0}, field={1}, err={2}
# InterfaceCellEmptyButHasNoDefaultImpl: source, interfaceName
F.InterfaceCellEmptyButHasNoDefaultImpl=空单元格类型为接口，没设置defaultImpl。source={0}, interface={1}
# InterfaceCellImplNotFound: source, interfaceName, notFoundImpl
F.InterfaceCellImplNotFound=接口无此实现。source={0}, interface={1}, impl={2}
# InternalError: internal
F.InternalError=内部错误。detail={0}
# FieldCellSpanNotEnough: source, nameable, field, expected, notEnoughDataSpan
F.FieldCellSpanNotEnough=需要的单元格个数不匹配。source={0}, struct={1}, field={2}, expected={3}, actual={4}
# FieldCellNotUsed: source, nameable, unused
F.FieldCellNotUsed=字段单元格未使用。source={0}, struct={1}, unused={2}
# NotMatchFieldType: source, nameable, field, expectedType
F.NotMatchFieldType=类型不匹配。source={0}, struct={1}, field={2}, expectedType={3}
# MapKeyDuplicated: source, nameable, field
F.MapKeyDuplicated=map key重复。source={0}, struct={1}, field={2}
# PrimaryOrUniqueKeyDuplicated: value, table, keys
F.PrimaryOrUniqueKeyDuplicated=键值重复。value={0}, table={1}, keys={2}
# EnumEmpty: source, table
F.EnumEmpty=枚举单元格为空。source={0}, table={1}
# EntryContainsSpace: source, table
F.EntryContainsSpace=入口或枚举包含空格。source={0}, table={1}
# EntryDuplicated: source, table
F.EntryDuplicated=入口或枚举重复。source={0}, table={1}
# MustFillButCellEmpty: value
F.MustFillButCellEmpty=字段标记为必填但单元格为空。value={0}
# RefNotNullableButCellEmpty: value, recordId
F.RefNotNullableButCellEmpty=ref没设置nullable，但单元格为空。value={0}, recordId={1}
# ForeignValueNotFound: value, recordId, foreignTable, foreignKey
F.ForeignValueNotFound=外键没找到对应值。value={0}, recordId={1}, foreignTable={2}, foreignKey={3}
# JsonFileReadErr: jsonFile, errMsg
F.JsonFileReadErr=json文件读取失败。file={0}, err={1}
# JsonStrEmpty: source
F.JsonStrEmpty=json字符串为空。source={0}
# JsonParseException: source, err
F.JsonParseException=json解析异常。source={0}, err={1}
# JsonTypeNotExist: source, expected
F.JsonTypeNotExist=json类型不存在。source={0}, expected={1}
# JsonTypeNotMatch: source, type, expected
F.JsonTypeNotMatch=json类型不匹配。source={0}, type={1}, expected={2}
# JsonValueNotMatchType: source, value, expectedType
F.JsonValueNotMatchType=json值与类型不匹配。source={0}, value={1}, expectedType={2}

# UnreferencedRecordCollector messages
UnreferencedRecordCollector.ResultHeader========== 未被引用的记录检查结果 ==========
UnreferencedRecordCollector.FoundTables=共发现 {0} 个table中有未被引用的记录
UnreferencedRecordCollector.TotalRecords=总计 {0} 条记录未被引用
UnreferencedRecordCollector.TableInfo=Table: {0} ({1}条未引用)
UnreferencedRecordCollector.IdeallyZero=（理想情况下为0，因为我们提供entry、enum机制可以避免在代码中出现魔数）
UnreferencedRecordCollector.CheckComplete========== 检查完成 ==========
UnreferencedRecordCollector.AllReferenced=未引用记录检查: 所有记录都被引用，没有发现未引用的记录。
GenVerifier.Title=引用检测；未引用记录检测(entry/enum/root算作被引用)；入口记录检测

# EntryRecordCollector messages
EntryRecordCollector.ResultHeader========== 入口记录检查结果 ==========
EntryRecordCollector.FoundTables=共发现 {0} 个包含入口记录的表
EntryRecordCollector.TotalRecords=共 {0} 条记录作为入口点
EntryRecordCollector.TableInfo=表：{0} {1} ({2}条入口记录)
EntryRecordCollector.CheckComplete========== 检查完成 ==========
EntryRecordCollector.NoEntry=入口记录检查：未找到入口记录。